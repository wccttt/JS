### 此页慎点，但是重要非常(日常吐槽)
- 1.私有作用域
    - 一个函数执行就会形成一个私有作用域,一个函数可执行多次,每一次都会形成一个私有作用域,每一个作用域都没有关系
- 2.闭包，
    - 一个私有作用域保护里面的私有变量不受外界干扰
    - 私有变量：私有作用域下声明的变量，形参
    - 闭包有什么作用
```js
//实现bind方法


```    
- 3.函数形成的过程
    - 函数执行形成私有作用域，变量提升，形参赋值，代码执行
- 4.作用域链
    - 在私有作用域下遇到变量了,先看是不是自己的私有变量,如果是就使用自己的私有变量,如果不是,往上一级找,没有继续找一直找到全局作用域为止,还找不到那就报错了,这个查找的过程就叫做作用域链
- 5.上一级作用域
    - 当前的作用域的地址在哪一个作用域下定义的,那么上一级作用域就是谁
- 6.块级作用域
    - 只要是{}包起来的都是块级作用域
    - 注意：在块级作用域中使用var和function定义的变量不可以重名的
    - 块级作用域针对 let const就相当于私有作用域,里面声明的变量外界是拿不到的
 - 7.暂时性死区
     
    - 在块级作用域下，不可以提前使用未被声明的(let,const声明的变量)
- 变量提升
   - 在作用域形成之后代码执行之前,将所有的带var和function关键字的变量提前的声明或定义   
   - var 的只声明未定义，function声明和定义同时发生
   - 变量提升的特殊问题
   - 1.自执行函数没有变量提升
   - 2.等号右边没有变量提升
   - 3.不管条件是否成立都要变量提声,但是,var 和function都是只声明不定义,当条件成立第一步先给函数赋值
   - 4.函数做参数的时候不进行变量提升
   - 5.return 后面的代码不执行但是需要变量提升，return出来的内容执行但是不进行变量提升
- 内存销毁的问题
   - 1.内存
      - 堆内存:存储引用数据类型的
      - 栈内存:作用域
   - 2.堆内存释放:
      - 当地某个堆内存的地址不再被变量占用,此时浏览器会在空闲的时候将其销毁
   - 注意:以后开发中后期不再使用的引用数据类型手动将其赋值为null
   - 3.栈内存的释放:
      - 全局作用域:当关闭浏览器的时候全局作用域销毁
      - 私有作用域:
      - 销毁:一个作用域没有被外界占用的内容,此时就销毁了
      - 不销毁:当一个私有作用域返回一个地址被外界占用了,此时这个作用域就不销毁   
- this指向问题(这个问题好恶心啊)
   - 首先，this表示执行主体，this是一个对象，this不是变量，所以this不可以赋值，在全局下this是window
   - 私有作用域下this问题
      - 1.看函数执行的时候前面有没有点，有点，那么点前面是谁，this就是谁
      - 2.给元素绑定事件的时候给谁绑定的this就是谁
      - 3.自执行函数中的this是window
      - 4.当一个函数当做回调函数的时候this是window，但是有些可以修改
      - 5.有bind,call,apply存在的情况下，会优先改变this的指向
      - 6.构造函数中 this指当前实例本身
      - 7.箭头函数中没有this，this是指当前箭头函数所在作用域的上下文   