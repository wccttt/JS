### 先了解一些概念
- 浏览器是多线程的，js是单线程的，当访问一个页面的时候每一个请求都要一个线程来处理
- 因为JS是单线程的，不能处理多的任务，所以浏览器给它分配，主任务队列，等待任务队列
#### 浏览器由哪些部分组成
- 1.用户界面 
- 2.浏览器引擎（the browser engine）— 用来查询及操作渲染引擎的接口； 
- 3.渲染引擎（the rendering engine）— 显示请求的内容； 
- 4.网络 — 用来完成网络调用，例如 HTTP 请求； 
- 5.UI 后端 — 用来回执类似组合框以及对话框等基本组件； 
- 6.JS 解释器 — 解释执行JS 代码； 
- 7.数据存储 — 属于持久层 ，浏览器或许会在本地保存各种数据，比如cookie
##### 什么是渲染引擎（浏览器内核）
- 渲染引擎负责解析HTML文档和渲染页面，主流的渲染引擎有：IE的Trident,火狐的Gecko,Safari和Chrome的WebKit等。渲染引擎首先通过网络获得请求文档的内容，之后进行文档内容的解析和页面的渲染，一般流程如下：    
- 解析html构建DOM tree—->结合样式规则构建render tree—>布局render tree—>绘制render tree
    

#### 这里引申了另一个概念，JS的单线程是怎么来的又什么优点？
   - 主要是提高效率
   - JavaScript的单线程，与它的用途有关。作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？
   - 为了利用多核CPU的计算能力，HTML5提出Web Worker标准，允许JavaScript脚本创建多个线程，但是子线程完 
     全受主线程控制，且不得操作DOM。所以，这个新标准并没有改变JavaScript单线程的本质
#### 什么叫任务队列
- (来点干货),所有的任务能被分为两种，一种是同步任务，一种是异步任务
  - 同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；
  - 异步任务指的是，不进入主线程、而进入”任务队列”（task queue）的任务，只有”任务队列”通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。
  - 那官方的异步执行的运行机制是怎么样的呢？
```js

  //（1）所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。
  //（2）主线程之外，还存在一个"任务队列"（task queue）。只要异步任务有了运行结果，就在"任务队列"之中放置一个事件。
  //（3）一旦"执行栈"中的所有同步任务执行完毕，系统就会读取"任务队列"，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。
 // （4）主线程不断重复上面的第三步。
```
     
     
 
###JS中有哪些异步操作
#### 宏任务(同步->微任务->宏任务)
- 定时器
- ajax
- 事件
- 回调函数(部分)
- setImmediate:node里的



#### 微任务
- Promise
- async  await
```js
//将函数变成一个promise的实例
function fn2() {
  return new Promise((res,rej)=>{
      setTimeout(()=>{
                res();

      },0)
  })
}
async function fn() {
    //return 100;
   var res=
   await fn2(); //await 后面一般添加的都是异步的操作，会执行这里面的方法
   //await 会先执行fn2里面的代码，执行结束之后开始执行主栈的同步，同步完成之后执行await后面的代码
    console.log(1000);
  
}
fn().then(res=>{
    console.log(res);//100
},rej=>{
    //fn函数报错，或者await函数有报错执行rej
})
```
- process.nextTick
```js

//node中的方法，会将回调函数放到异步当中当中的开头位置，执行完同步后，立即执行它
```